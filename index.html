<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>JURIGO JUMP</title>
<style>
  :root{
    --deep:#223A6B;     /* Jurigo djup blå (bakgrund) */
    --beige:#D8CAB8;    /* Jurigo beige (plattformar) */
    --white:#FFFFFF;
    --blue:#2D7FF9;     /* Blå pickups/buff */
    --haz1:#FF5722;     /* Farliga objekt */
    --haz2:#FF3B30;
    --shield:#22C55E;   /* Sköld-aura */
  }
  html,body{margin:0;height:100%;background:var(--deep);color:var(--white);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overflow:hidden;}
  .wrap{display:flex;align-items:center;justify-content:center;min-height:100vh;padding:12px;}
  /* Canvasen skalas max 420x780 för att passa inbäddning utan scroll */
  canvas{display:block;width:min(100%,420px);height:min(100vh - 24px,780px);max-width:420px;max-height:780px;background:linear-gradient(180deg,#1e335f 0%, #223A6B 60%, #1a2a52 100%);border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,.25);outline:1px solid rgba(255,255,255,.06)}
  .hud{position:absolute;inset:0;display:flex;align-items:flex-start;justify-content:center;pointer-events:none}
  .fly{position:absolute;color:var(--blue);font-weight:600;opacity:.95;transform:translate(-50%,-50%);text-shadow:0 1px 2px rgba(0,0,0,.35)}
  .vignette{position:absolute;inset:0;pointer-events:none;box-shadow:inset 0 0 160px rgba(255,59,48,.16);opacity:0;transition:opacity .15s ease}
  .vignette.on{opacity:1}
  .win{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(1.5px);color:#fff;font-size:22px;font-weight:700;letter-spacing:.3px;text-align:center}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  /* Visning av poäng/kronor överst i spelfältet */
  #scoreDisplay{
    position:absolute;
    top:16px;
    left:16px;
    z-index:30;
    color:var(--white);
    font-size:16px;
    font-weight:600;
    pointer-events:none;
  }

  /* Piltangenter för mobil/touch */
  #controls{
    position:absolute;
    bottom:20px;
    left:50%;
    transform:translateX(-50%);
    display:flex;
    gap:40px;
    z-index:10;
  }
  #controls button{
    width:60px;
    height:60px;
    border-radius:50%;
    background:var(--beige);
    color:var(--deep);
    border:none;
    font-size:32px;
    font-weight:700;
    line-height:1;
    box-shadow:0 2px 4px rgba(0,0,0,0.2);
    /* Förhindra att textmarkering dyker upp när man håller in knappen på mobil */
    user-select:none;
    -webkit-user-select:none;
    -ms-user-select:none;
    -moz-user-select:none;
    /* Ta bort tap-höjdpunkt på mobila enheter och undvik fokusring */
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    outline:none;
    touch-action: manipulation;
  }
  #controls button:active{
    transform:scale(0.95);
  }
  /* Dölj pilar på bredare skärmar */
  @media (min-width:600px){
    #controls{display:none;}
  }

  /* Meny och instruktioner overlay */
  #menuOverlay, #instructionsOverlay {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(34,58,107,0.95);
    z-index:20;
  }
  #menuOverlay .menu-content, #instructionsOverlay .menu-content {
    text-align:center;
    color:var(--white);
    max-width:340px;
    padding:20px;
  }
  #menuOverlay button, #instructionsOverlay button {
    margin:8px 4px;
    padding:12px 28px;
    font-size:20px;
    font-weight:600;
    background:var(--beige);
    color:var(--deep);
    border:none;
    border-radius:8px;
    cursor:pointer;
  }
  #instructionsOverlay p {
    margin-bottom:16px;
    font-size:14px;
    line-height:1.3;
  }

  /* Gör länken för e-postadress i instruktionerna tydligare */
  #instructionsOverlay a {
    color: var(--beige);
    text-decoration: underline;
  }

  /* Meny och instruktioner overlay */
  #menuOverlay, #instructionsOverlay {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(34,58,107,0.95);
    z-index:20;
  }
  #menuOverlay .menu-content, #instructionsOverlay .menu-content {
    text-align:center;
    color:var(--white);
    max-width:340px;
    padding:20px;
  }
  #menuOverlay button, #instructionsOverlay button {
    margin:8px 4px;
    padding:12px 28px;
    font-size:20px;
    font-weight:600;
    background:var(--beige);
    color:var(--deep);
    border:none;
    border-radius:8px;
    cursor:pointer;
  }
  #instructionsOverlay p {
    margin-bottom:16px;
    font-size:14px;
    line-height:1.3;
  }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="420" height="780" aria-label="Jurigo Jump"></canvas>
  <div class="hud" aria-hidden="true">
    <div id="vignette" class="vignette"></div>
  </div>
      <!-- Poängvisare -->
      <!-- Visar antalet poäng (utan valuta). Varje poäng omvandlas till kronor vid slutet. -->
      <div id="scoreDisplay">Poäng: 0</div>
</div>

<!-- Piltangenter för mobila enheter -->
<div id="controls">
  <button id="leftBtn" aria-label="Vänster">&#9664;</button>
  <button id="rightBtn" aria-label="Höger">&#9654;</button>
</div>

<!-- Meny och instruktioner overlay -->
<div id="menuOverlay">
  <div class="menu-content">
    <h2>JURIGO JUMP</h2>
    <button id="startBtn">START</button>
    <button id="instrBtn">INSTRUKTIONER</button>

    <!-- Anpassningspanel för att välja figur, tillbehör och färg -->
    <div id="customizePanel" style="margin-top:16px; text-align:left; color:var(--white);">
      <p style="margin:4px 0 2px 0; font-size:16px;">Välj figur:</p>
      <select id="genderSelect" style="width:100%; padding:6px; margin-bottom:6px; border-radius:4px; border:1px solid var(--beige); background:var(--beige); color:var(--deep);">
        <option value="male">Man</option>
        <option value="female">Kvinna</option>
      </select>
      <p style="margin:4px 0 2px 0; font-size:16px;">Välj tema:</p>
      <select id="accessorySelect" style="width:100%; padding:6px; margin-bottom:6px; border-radius:4px; border:1px solid var(--beige); background:var(--beige); color:var(--deep);">
        <option value="gavel">Domarklubba</option>
        <option value="law">Lagtema</option>
      </select>
      <p style="margin:4px 0 2px 0; font-size:16px;">Färg på kläder:</p>
      <select id="colorSelect" style="width:100%; padding:6px; border-radius:4px; border:1px solid var(--beige); background:var(--beige); color:var(--deep);">
        <option value="#D8CAB8">Beige</option>
        <option value="#2D7FF9">Blå</option>
        <option value="#FFFFFF">Vit</option>
      </select>
    </div>
  </div>
</div>
<div id="instructionsOverlay" style="display:none;">
  <div class="menu-content">
    <h2>Instruktioner</h2>
    <p>Hoppa från plattform till plattform och samla lagböcker (+10&nbsp;poäng) och paragrafer (+5&nbsp;poäng) för att öka din poäng och få en skyddande sköld. Undvik de röda farorna! Vissa plattformar är sköra och bryts efter tre hopp. Varje poäng motsvarar en krona i rabatt när spelet är slut, upp till&nbsp;500&nbsp;kr. I slutet av spelet får du en värdekod med samma belopp som dina poäng att använda på din första juridiska fråga hos Jurigo.</p>
    <p>Om du vill använda din kod direkt kan du ställa din fråga till <a href="mailto:jurist@jurigo.se">jurist@jurigo.se</a> och ange koden. Efter att spelet avslutats kan du enkelt kopiera koden genom att klicka direkt på koden eller använda knappen <em>Kopiera kod</em> som visas på skärmen. Vi återkommer inom 48&nbsp;timmar med hur vi går vidare och vad det nya priset blir. Efter ditt godkännande kan arbetet påbörjas. Att ställa en fråga eller initiera en första kontakt kostar inget förrän du har godkänt kostnaden.</p>
    <button id="backBtn">TILLBAKA</button>
  </div>
</div>

<!-- Slutresultat-overlay med kupongkod och knappar -->
<div id="endOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:10; align-items:center; justify-content:center;">
  <div class="end-content" style="background:var(--deep); color:var(--white); padding:24px; border-radius:8px; max-width:380px; margin:0 auto; text-align:center;">
    <h2 id="endTitle" style="margin-top:0; margin-bottom:12px;"></h2>
    <p id="endScore" style="margin:0 0 12px 0;"></p>
    <p id="endCode" style="font-family:'Courier New', monospace; font-size:18px; color:var(--blue); margin:0 0 12px 0;"></p>
    <p id="expiryInfo" style="margin:0 0 8px 0;"></p>
    <p id="instructionsInfo" style="margin:0 0 16px 0;"></p>
    <button id="copyBtn" style="padding:8px 16px; margin:6px 0; background:var(--beige); color:var(--deep); border:none; border-radius:4px; font-weight:600; cursor:pointer; width:100%;">KOPIERA KOD</button>
    <button id="againBtn" style="padding:8px 16px; margin:6px 0; background:var(--beige); color:var(--deep); border:none; border-radius:4px; font-weight:600; cursor:pointer; width:100%;">SPELA IGEN</button>
    <button id="endInstrBtn" style="padding:8px 16px; margin:6px 0; background:var(--beige); color:var(--deep); border:none; border-radius:4px; font-weight:600; cursor:pointer; width:100%;">INSTRUKTIONER</button>
  </div>
</div>

<script>
(() => {
  // ======= Konstanter & färger =======
  const COLOR = {
    bg: "#223A6B",
    plat: "#D8CAB8",
    white: "#FFFFFF",
    blue: "#2D7FF9",
    haz1: "#FF5722",
    haz2: "#FF3B30",
    shield: "#22C55E"
  };

  // Canvas
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // Elementreferenser för slutoverlay
  const endOverlay = document.getElementById("endOverlay");
  const endTitle    = document.getElementById("endTitle");
  const endScoreElem    = document.getElementById("endScore");
  const endCodeElem     = document.getElementById("endCode");
  const expiryInfoElem  = document.getElementById("expiryInfo");
  const instructionsInfoElem = document.getElementById("instructionsInfo");
  const copyBtn = document.getElementById("copyBtn");
  const againBtn = document.getElementById("againBtn");
  // Instruktionsknapp i slut-overlay
  const endInstrBtn = document.getElementById("endInstrBtn");
  // Element som visar kupongkod i slut-overlay
  // endCodeElem är redan definierad ovanför och används för att visa koden

  // Kopiera kupongkod till urklipp
  copyBtn.addEventListener('click', () => {
    if (couponCode) {
      navigator.clipboard.writeText(couponCode).then(() => {
        copyBtn.textContent = 'KOPIERAD!';
        setTimeout(() => {
          copyBtn.textContent = 'KOPIERA KOD';
        }, 2000);
      });
    }
  });

  // Gör det möjligt att kopiera koden genom att klicka direkt på koden
  endCodeElem.addEventListener('click', () => {
    if (couponCode) {
      navigator.clipboard.writeText(couponCode).then(() => {
        copyBtn.textContent = 'KOPIERAD!';
        setTimeout(() => {
          copyBtn.textContent = 'KOPIERA KOD';
        }, 2000);
      });
    }
  });

  // Starta om spelet utan att ladda om sidan
  againBtn.addEventListener('click', () => {
    endOverlay.style.display = 'none';
    copyBtn.textContent = 'KOPIERA KOD';
    gameOver = false;
    resetGame();
    gameStarted = true;
    // starta loop
    requestAnimationFrame(loop);
  });

  // Visa instruktioner när man klickar på Instruktionsknappen i slut-overlay
  if (endInstrBtn) {
    endInstrBtn.addEventListener('click', () => {
      // Dölj slut-overlay och visa instruktioner
      endOverlay.style.display = 'none';
      if (instructionsOverlay) instructionsOverlay.style.display = 'flex';
    });
  }

  // Visa slutoverlay med kod och information
  function showEndOverlay(){
    // Generera kupong om den inte redan finns
    if (!couponCode) {
      const res = generateCoupon(currentAmount);
      couponCode = res.code;
      couponExpiry = res.expiry;
    }
    // Titel och information om poäng och rabatt
    if (currentAmount >= SCORE_CAP) {
      // Maxpoäng: visa gratulation och värde på kupongen
      endTitle.textContent = 'GRATTIS! Du maxade 500 poäng';
      endScoreElem.textContent = 'Din värdekod ger 500 kr i rabatt';
    } else {
      endTitle.textContent = 'Spelet över';
      endScoreElem.textContent = 'Du nådde ' + score + ' poäng (värde ' + currentAmount + ' kr)';
    }
    // Kod och giltighet
    endCodeElem.textContent = couponCode;
    const expiryStr = couponExpiry.toLocaleDateString('sv-SE');
    expiryInfoElem.textContent = 'Giltig t.o.m. ' + expiryStr;
    // Ange att koden motsvarar rabatten och hur man använder den
    instructionsInfoElem.textContent = 'Din värdekod är värd ' + currentAmount + ' kr. Kopiera koden och ange den i ditt mejl till jurist@jurigo.se för att få avdrag.';
    endOverlay.style.display = 'flex';
  }

  // ======= Spelarens status =======
  const player = {
    x: W*0.5 - 20,
    y: H*0.7,
    w: 40,
    h: 60,
    vx: 0,
    vy: 0,
    onGround: false,
    hasShield: false,
    shieldTime: 0,   // sek
    iFrames: 0,      // sek
  };

  // Kuponkod och giltighet (genereras vid vinst)
  let couponCode = null;
  let couponExpiry = null;

  // Spelstatusflaggor
  // gameStarted: spelet körs när detta är sant. Innan dess visas menyn.
  // gameOver: spelet är avslutat (antingen vinst eller förlust) och en kupong visas.
  // currentAmount: den avrundade kronbonus som spelaren erhåller vid gameOver.
  let gameStarted = false;
  let gameOver = false;
  let currentAmount = 0;

  // ======= Poäng/KR (1:1) =======
  let score = 0;            // 0..500
  const SCORE_CAP = 500;

  // ======= Anpassningsval (figur, tillbehör, färg) =======
  // Dessa variabler uppdateras via val i menyn före spelets start.
  // Standardval: manlig figur, domarklubba som tillbehör, beige klädsel.
  let selectedGender = 'male';
  let selectedAccessory = 'gavel';
  let selectedColor = '#D8CAB8';

  // ======= Plattformar (alltid nåbara) =======
  const platH = 12;
  const initialPlatforms = 10;
  let platforms = [];
  let lastPlatX = W*0.5 - 40;

  // Reachability: begränsa vert/hor gap
  const MAX_VERT_GAP = 110;         // pixlar
  const MAX_HORZ_SHIFT = 80;        // pixlar sidled mellan successiva plattformar

  // ======= Fallande objekt =======
  // Bra (blå) ger poäng + sköld
  let blueDrops = []; // {x,y,v,type:'law'|'para'}
  // Farliga (röd/orange) dödar om ingen sköld
  let hazDrops = [];  // {x,y,v,type:'fire'|'bolt'|'rock'}

  // Spawn-accumulatorer för sannolikheter per frame
  let spawnAccBlue = 0, spawnAccHaz = 0;

  // ======= Andrum & storm-bursts =======
  let andrumActive = false;
  let andrumUntil = 0;
  let nextAndrumAt = randRange(12,18);
  let stormBurstActive = false;
  let stormUntil = 0;
  let nextStormAt = Infinity;

  // ======= Fly-up text =======
  const flyups = []; // {x,y,text,t}

  // ======= Kontroller =======
  const keys = { left:false, right:false };
  addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft") keys.left=true;
    if(e.key==="ArrowRight") keys.right=true;
  });
  addEventListener("keyup", e=>{
    if(e.key==="ArrowLeft") keys.left=false;
    if(e.key==="ArrowRight") keys.right=false;
  });

  // Touch / muskontroller för pilarna på mobila enheter
  const leftBtnElem = document.getElementById('leftBtn');
  const rightBtnElem = document.getElementById('rightBtn');
  if (leftBtnElem && rightBtnElem) {
    const startLeft = (ev) => { ev.preventDefault(); keys.left = true; };
    const endLeft   = (ev) => { ev.preventDefault(); keys.left = false; };
    const startRight= (ev) => { ev.preventDefault(); keys.right = true; };
    const endRight  = (ev) => { ev.preventDefault(); keys.right = false; };
    ['mousedown','touchstart'].forEach(evType => {
      leftBtnElem.addEventListener(evType, startLeft);
      rightBtnElem.addEventListener(evType, startRight);
    });
    ['mouseup','touchend','touchcancel','mouseleave'].forEach(evType => {
      leftBtnElem.addEventListener(evType, endLeft);
      rightBtnElem.addEventListener(evType, endRight);
    });
  }

  // === Meny och instruktioner ===
  const menuOverlay = document.getElementById('menuOverlay');
  const instructionsOverlay = document.getElementById('instructionsOverlay');
  const startBtn = document.getElementById('startBtn');
  const instrBtn = document.getElementById('instrBtn');
  const backBtn = document.getElementById('backBtn');
  // Element för att visa aktuell poäng/kronor
  const scoreDisplay = document.getElementById('scoreDisplay');
  // Visa menyn initialt
  if (menuOverlay) menuOverlay.style.display = 'flex';
  // Startknapp
  if (startBtn) {
    startBtn.addEventListener('click', () => {
      gameStarted = true;
      gameOver = false;
      currentAmount = 0;
      if (menuOverlay) menuOverlay.style.display = 'none';
      if (instructionsOverlay) instructionsOverlay.style.display = 'none';
      resetGame();
    });
  }
  // Instruktionsknapp
  if (instrBtn) {
    instrBtn.addEventListener('click', () => {
      if (instructionsOverlay) instructionsOverlay.style.display = 'flex';
      if (menuOverlay) menuOverlay.style.display = 'none';
    });
  }
  // Tillbaka-knapp
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      if (instructionsOverlay) instructionsOverlay.style.display = 'none';
      if (menuOverlay) menuOverlay.style.display = 'flex';
    });
  }

  // === Anpassningsval för figur, tillbehör och färg ===
  // Hämtar referenser till select-elementen i menyoverlay och lyssnar på ändringar.
  const genderSelectElem = document.getElementById('genderSelect');
  const accessorySelectElem = document.getElementById('accessorySelect');
  const colorSelectElem = document.getElementById('colorSelect');
  if (genderSelectElem) {
    selectedGender = genderSelectElem.value;
    genderSelectElem.addEventListener('change', (e) => {
      selectedGender = e.target.value;
    });
  }
  if (accessorySelectElem) {
    selectedAccessory = accessorySelectElem.value;
    accessorySelectElem.addEventListener('change', (e) => {
      selectedAccessory = e.target.value;
    });
  }
  if (colorSelectElem) {
    selectedColor = colorSelectElem.value;
    colorSelectElem.addEventListener('change', (e) => {
      selectedColor = e.target.value;
    });
  }
  // Starta spelet med Enter eller Space när menyn är synlig
  addEventListener('keydown', e => {
    if (!gameStarted && (e.key === 'Enter' || e.key === ' ')) {
      gameStarted = true;
      gameOver = false;
      currentAmount = 0;
      if (menuOverlay) menuOverlay.style.display = 'none';
      if (instructionsOverlay) instructionsOverlay.style.display = 'none';
      resetGame();
    }
  });

  // ======= Init =======
  initPlatforms();
  let lastTime = performance.now();
  requestAnimationFrame(loop);

  function initPlatforms(){
    platforms.length = 0;
    let y = H - 30;
    for(let i=0;i<initialPlatforms;i++){
      const w = 80;
      const x = clamp(lastPlatX + randRange(-MAX_HORZ_SHIFT, MAX_HORZ_SHIFT), 8, W - w - 8);
      // Bestäm om plattformen ska vara skör (30 % sannolikhet)
      let isFragile = Math.random() < 0.3;
      let hits = isFragile ? 3 : Infinity;
      // Gör den första (nedersta) plattformen alltid stabil så spelaren inte behöver stressa direkt i början
      if (i === 0) {
        isFragile = false;
        hits = Infinity;
      }
      platforms.push({x, y, w, fragile:isFragile, hitsLeft:hits});
      lastPlatX = x;
      y -= MAX_VERT_GAP * 0.9; // lite lättare i början
    }
    // Sätt spelaren strax över nedersta
    player.x = platforms[0].x + platforms[0].w/2 - player.w/2;
    player.y = platforms[0].y - player.h - 2;
    player.vy = 0;
  }

  // Återställ spelet till startläge
  function resetGame(){
    // Nollställ poäng och spelaregenskaper
    score = 0;
    player.x = W*0.5 - player.w/2;
    player.y = H*0.7;
    player.vx = 0;
    player.vy = 0;
    player.hasShield = false;
    player.shieldTime = 0;
    player.iFrames = 0;
    // Nollställ plattformar
    lastPlatX = W*0.5 - 40;
    initPlatforms();
    // Nollställ fallande objekt
    blueDrops = [];
    hazDrops = [];
    spawnAccBlue = 0;
    spawnAccHaz = 0;
    // Nollställ andrum & storm
    andrumActive = false;
    andrumUntil = 0;
    nextAndrumAt = randRange(12,18);
    stormBurstActive = false;
    stormUntil = 0;
    nextStormAt = Infinity;
    // Reset gameclock och kuponter
    gameClock = 0;
    couponCode = null;
    couponExpiry = null;
  }

  // ======= Easing & parametrisering =======
  const clamp01 = v => Math.max(0, Math.min(1, v));
  const easeInCubic = t => t*t*t;
  const easeOutQuad = t => 1 - (1-t)*(1-t);

  function paramsByScore(s){
    const t = clamp01(s / SCORE_CAP);               // 0..1
    const E = easeInCubic(t);
    const D = easeOutQuad(t);

    // Rates (per sekund)
    // Grundvärden för spawnfrekvens. Med högre slutvärden för farliga objekt
    // och lägre för blå objekt blir spelet svårare i högre poängintervall.
    let H0 = 0.8, Hmax = 5.2;           // start- och maxhastighet för faror (per sekund)
    let hazardRate = H0 + (Hmax - H0) * E;

    let B0 = 1.0, Bmin = 0.20;          // start- och minimihastighet för blå objekt
    let blueRate = Math.max(Bmin, B0 * (1 - 0.75 * D));

    // Caps (samtidiga)
    const maxHaz = Math.round(8 + 10*E);   // 8..18
    const maxBlue = Math.round(6 - 4*D);   // 6..2

    // Speeds (px/s)
    const vh = 220 + (520-220)*E;          // hazard speed
    const vb = 180 + 120*D;                // blue speed

    // Milestones: öka faror mer och minska blå för varje tröskel
    if (s >= 100) {
      hazardRate *= 1.05;
      blueRate   *= 0.90;
    }
    if (s >= 200) {
      hazardRate *= 1.20;
      blueRate   *= 0.85;
    }
    if (s >= 300) {
      hazardRate *= 1.25;
      blueRate   *= 0.85;
    }
    if (s >= 400) {
      hazardRate *= 1.35;
      blueRate   *= 0.80;
    }

    return {hazardRate, blueRate, maxHaz, maxBlue, vh, vb};
  }

  // Andrumplanering & storm
  function scheduleWindows(dt){
    const s = score;
    const now = gameClock;

    // Andrums-pulsar var 12–18 s i 2 s (eller 1.5 s >400)
    if (!andrumActive && now >= nextAndrumAt){
      andrumActive = true;
      const dur = (s>=400)? 1.5 : 2.0;
      andrumUntil = now + dur;
    }
    if (andrumActive && now >= andrumUntil){
      andrumActive = false;
      nextAndrumAt = now + randRange(12,18);
    }

    // Storm bursts 450–500: var 6–8 s, 1 s
    if (s >= 450 && !stormBurstActive && now >= nextStormAt){
      stormBurstActive = true;
      stormUntil = now + 1.0;
    }
    if (stormBurstActive && now >= stormUntil){
      stormBurstActive = false;
      nextStormAt = now + randRange(6,8);
    }
  }

  // ======= Spel-loop =======
  let gameClock = 0; // sek
  function loop(ts){
    const dt = Math.min(0.033, (ts - lastTime)/1000); // cappa dt ~30fps
    lastTime = ts;
    // Om spelet inte startat ännu, vänta och rita bara meny/instruktioner
    if (!gameStarted) {
      requestAnimationFrame(loop);
      return;
    }
    // Om spelet är över, visa slutoverlay och avbryt
    if (gameOver) {
      showEndOverlay();
      return;
    }
    gameClock += dt;

    update(dt);
    draw(dt);

    if (score >= SCORE_CAP){
      // Vinst: sätt belopp till max och avsluta
      currentAmount = SCORE_CAP;
      gameOver = true;
      // Visa slutoverlay nästa frame
      showEndOverlay();
      return;
    }
    requestAnimationFrame(loop);
  }

  // ======= Update =======
  function update(dt){
    scheduleWindows(dt);
    // Rörelse vänster/höger
    const accel = 750; // px/s^2
    const maxVx = 260;
    if (keys.left)  player.vx = clamp(player.vx - accel*dt, -maxVx,  maxVx);
    else if (keys.right) player.vx = clamp(player.vx + accel*dt, -maxVx,  maxVx);
    else player.vx *= 0.88;

    player.x += player.vx * dt;
    // wrap-kanter
    if (player.x < -player.w) player.x = W;
    if (player.x > W) player.x = -player.w;

    // Gravitation / studs
    player.vy += 1100 * dt;
    player.y  += player.vy * dt;

    // Plattform-kollision nedåt
        if (player.vy > 0){
      for (const p of platforms){
        if (rectHit(player.x, player.y, player.w, player.h, p.x, p.y, p.w, platH)){
          if (player.y + player.h <= p.y + player.vy*dt + 6){
            player.y = p.y - player.h;
            player.vy = -720;     // studs
            // Om plattformen är skör, minska återstående hopp och bryt vid noll
            if (p.hitsLeft !== Infinity){
              p.hitsLeft--;
              if (p.hitsLeft <= 0){
                // flytta plattformen nedanför skärmen så att den återanvänds vid reposition
                p.y = H + 60;
              }
            }
            break;
          }
        }
      }
    }

    // Kamera uppåt = öka poäng (KR 1:1)
    const cameraTop = H*0.4;
    if (player.y < cameraTop){
      const dy = cameraTop - player.y;
      player.y += dy;
      for (const p of platforms) p.y += dy;
      for (const o of blueDrops) o.y += dy;
      for (const o of hazDrops)  o.y += dy;
      score = Math.min(SCORE_CAP, Math.round(score + dy*0.05)); // 20px ≈ 1 kr (tweakad)
    }

    // Återanvänd plattformar (alltid nåbara)
    for (const p of platforms){
      if (p.y > H + 40){
        // ny v-y
        p.y -= MAX_VERT_GAP * platforms.length;
        // ny bredd
        p.w = clamp(60 + randRange(-10, 40), 52, 110);
        // begränsad sidledsförflyttning
        p.x = clamp(lastPlatX + randRange(-MAX_HORZ_SHIFT, MAX_HORZ_SHIFT), 8, W - p.w - 8);
        lastPlatX = p.x;
        // tilldela ny fragilitet: 30 % sannolikhet för skör plattform
        const isFragile = Math.random() < 0.3;
        p.fragile = isFragile;
        p.hitsLeft = isFragile ? 3 : Infinity;
      }
    }

    // Spawns – parametrar
    let {hazardRate, blueRate, maxHaz, maxBlue, vh, vb} = paramsByScore(score);
    // Öka fallhastigheten på faror i steg för varje 100 kr
    if (score >= 100) vh *= 1.10;
    if (score >= 200) vh *= 1.20;
    if (score >= 300) vh *= 1.30;
    if (score >= 400) vh *= 1.40;
    // Andrum
    if (andrumActive){ hazardRate *= 0.7; blueRate *= 1.2; }
    // Storm burst
    if (stormBurstActive){ hazardRate *= 1.3; /* garanti blå hanteras nedan */ }

    // Konvertera per sekund → sannolikhet via ackumulation
    spawnAccHaz += hazardRate * dt;
    spawnAccBlue += blueRate  * dt;

    const noSpawnXMin = player.x - W*0.15;
    const noSpawnXMax = player.x + player.w + W*0.15;

    // Hazards
    while (spawnAccHaz > 1 && hazDrops.length < maxHaz){
      spawnAccHaz -= 1;
      let hx;
      /*
       * Placera faror slumpmässigt över hela skärmen. För att öka intensiteten mot slutet
       * ökar sannolikheten att faror spawnar inom spelarens kon. Detta gör att
       * farliga objekt faller ovanför spelaren ibland och ökar risken för kollision.
       */
      const t = Math.min(1, score / SCORE_CAP);
      const probInside = 0.2 + 0.6 * t; // 20% i början, upp till 80% vid 500 kr
      if (Math.random() < probInside) {
        // helt slumpmässig X-position (ingen no-spawn cone)
        hx = randRange(18, W - 18);
      } else {
        // undvik spelarens direkta kon för att lämna utrymme
        hx = pickXAvoidCone(noSpawnXMin, noSpawnXMax, 14);
      }
      if (hx !== null && minHazSeparationOK(hx)){
        hazDrops.push({x:hx, y:-24, v: vh*(0.9+Math.random()*0.2), type: pickHazardType()});
      }
    }
    // Blues (garanti under storm)
    let needBlue = stormBurstActive && (blueDrops.length === 0);
    while ((spawnAccBlue > 1 || needBlue) && blueDrops.length < maxBlue){
      if (!needBlue) spawnAccBlue -= 1;
      needBlue = false;
      const bx = pickBlueX(noSpawnXMin, noSpawnXMax);
      blueDrops.push({x:bx, y:-18, v: vb*(0.9+Math.random()*0.2), type: Math.random()<0.6?"law":"para"});
    }

    // Uppdatera fall
    for (const o of hazDrops)  o.y += o.v * dt;
    for (const o of blueDrops) o.y += o.v * dt;

    // Despawn off-screen
    hazDrops = hazDrops.filter(o => o.y < H*1.2);
    blueDrops = blueDrops.filter(o => o.y < H*1.4);

    // Kollisioner (förlåtande hitboxar 88%)
    const phit = shrinkRect(player, .88);

        // – Hazards
    for (let i=hazDrops.length-1;i>=0;i--){
      const h = hazDrops[i];
      // Ge farorna en något större hitbox för bättre träffsäkerhet
      const r = {x:h.x-12,y:h.y-12,w:24,h:24};
      if (rectHitObj(phit, r)){
        if (player.hasShield || player.iFrames>0){
          hazDrops.splice(i,1); // neutralisera
        } else {
          // Spelaren dör: beräkna kupongbelopp och avsluta spelet
          // Runda upp till närmaste 50 kr, max 450 kr (om inte full vinst)
          if (score >= SCORE_CAP) {
            currentAmount = SCORE_CAP;
          } else if (score > 0) {
            const rounded = Math.ceil(score / 50) * 50;
            currentAmount = Math.min(SCORE_CAP - 50, rounded);
          } else {
            currentAmount = 0;
          }
          gameOver = true;
          return;
        }
      }
    }

    // – Blues
    for (let i=blueDrops.length-1;i>=0;i--){
      const b = blueDrops[i];
      const r = {x:b.x-10,y:b.y-10,w:20,h:20};
      if (rectHitObj(phit, r)){
        const val = (b.type==="law")? 10 : 5;
        score = Math.min(SCORE_CAP, score + val);
        // fly-up: visa endast antal poäng (inte valuta) när spelaren plockar ett föremål
        flyups.push({x:player.x+player.w/2, y:player.y-10, text:`+${val}`, t:0});
        // sköld
        extendShield((b.type==="law")?5.0:3.0);
        blueDrops.splice(i,1);
      }
    }

    // Sköld-timers
    if (player.hasShield){
      player.shieldTime -= dt;
      if (player.shieldTime <= 0){
        player.hasShield = false;
        player.shieldTime = 0;
        player.iFrames = 0.35;
      }
    }
    if (player.iFrames>0) player.iFrames -= dt;

    // “Fara nära” vignette
    const near = hazDrops.some(h => Math.abs((h.x)-(player.x+player.w/2)) < 40 && h.y > player.y-60 && h.y < player.y+120);
    document.getElementById("vignette").classList.toggle("on", near);

    // Flyups
    for (let i=flyups.length-1;i>=0;i--){
      const f = flyups[i];
      f.t += dt;
      f.y -= 36*dt;
      if (f.t > 0.9) flyups.splice(i,1);
    }

    // Om spelaren har fallit nedanför skärmen (missat plattform) ska spelet avslutas
    // Kontrollera efter övriga uppdateringar för att undvika studs mot borttagna plattformar
    if (!gameOver && player.y > H) {
      // Beräkna kupongbelopp baserat på uppnådd poäng (avrundas uppåt till närmaste 50, max 450)
      if (score >= SCORE_CAP) {
        currentAmount = SCORE_CAP;
      } else if (score > 0) {
        const rounded = Math.ceil(score / 50) * 50;
        currentAmount = Math.min(SCORE_CAP - 50, rounded);
      } else {
        currentAmount = 0;
      }
      gameOver = true;
      return;
    }
  }

  function draw(dt){
        // Clear
        ctx.clearRect(0,0,W,H);
        // Uppdatera text i poängvisaren (utanför canvas)
        if (scoreDisplay) {
          // Visa endast poäng i löpande spelet. Poängen omvandlas till kronor i slutet.
          scoreDisplay.textContent = `Poäng: ${score}`;
        }

        // Plattformar med skörhet och sprickor
        for (const p of platforms){
          if (p.hitsLeft !== Infinity) {
            // Skör: vit plattform med sprickor beroende på återstående hopp
            roundedRect(p.x, p.y, p.w, platH, 6, COLOR.white, true);
            drawCracks(p.x, p.y, p.w, platH, p.hitsLeft);
          } else {
            // Stabil
            roundedRect(p.x, p.y, p.w, platH, 6, COLOR.plat, true);
          }
        }

        // Poängen visas i scoreDisplay istället för att ritas i canvas

    // Spelare
    // Sköld-aura
    if (player.hasShield){
      const pulse = 0.85 + 0.15*Math.sin(gameClock*6);
      ctx.beginPath();
      ctx.ellipse(player.x+player.w/2, player.y+player.h/2, player.w*0.65*pulse, player.h*0.7*pulse, 0, 0, Math.PI*2);
      ctx.strokeStyle = COLOR.shield;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.85;
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    drawJudge(player.x, player.y, player.w, player.h);

    // Bra objekt
    for (const b of blueDrops) drawBlue(b.x, b.y, b.type);
    // Farliga
    for (const h of hazDrops)  drawHaz(h.x, h.y, h.type);

    // Fly-ups
    ctx.font = "bold 16px system-ui, sans-serif";
    ctx.fillStyle = COLOR.blue;
    ctx.textAlign = "center";
    for (const f of flyups){
      ctx.globalAlpha = Math.max(0, 1 - f.t/0.9);
      ctx.fillText(f.text, f.x, f.y);
      ctx.globalAlpha = 1;
    }
    ctx.textAlign = "start";
  }

  function winOverlay(){
    // Vinst-overlay med genererad kupongkod
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    // Generera kupongkod en gång
    if (!couponCode){
      const {code, expiry} = generateCoupon();
      couponCode = code;
      couponExpiry = expiry;
    }
    ctx.font = "700 26px system-ui, sans-serif";
    ctx.fillText("GRATTIS!", W/2, H/2 - 40);
    ctx.font = "20px system-ui, sans-serif";
    ctx.fillText("Du vann 500 kr", W/2, H/2 - 12);
    ctx.font = "16px system-ui, sans-serif";
    ctx.fillText("Kupongkod:", W/2, H/2 + 16);
    ctx.font = "bold 20px monospace";
    ctx.fillStyle = COLOR.blue;
    ctx.fillText(couponCode, W/2, H/2 + 40);
    ctx.fillStyle = "#fff";
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    const expiryStr = couponExpiry.toLocaleDateString('sv-SE', options);
    ctx.font = "14px system-ui, sans-serif";
    ctx.fillText(`Giltig till ${expiryStr}`, W/2, H/2 + 64);
    ctx.font = "14px system-ui, sans-serif";
    ctx.fillText("Presentera koden för 500 kr avdrag.", W/2, H/2 + 86);
    ctx.font = "12px system-ui, sans-serif";
    ctx.fillText("Ladda om sidan för att spela igen.", W/2, H/2 + 108);
    ctx.textAlign = "start";
  }

  function endGame(){
    // mjuk “död”-overlay
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#fff";
    ctx.font = "700 24px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Aj! Försök igen.", W/2, H/2 - 8);
    ctx.fillText("Ladda om sidan.", W/2, H/2 + 20);
    ctx.textAlign = "start";
  }

  // ======= Rit-hjälpare =======
  function roundedRect(x,y,w,h,r,color,fill=true){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if (fill){ ctx.fillStyle = color; ctx.fill(); }
    else { ctx.strokeStyle = color; ctx.stroke(); }
  }

  function drawJudge(x,y,w,h){
    // Rita kroppen baserat på vald figur (male/female) och färg
    const bodyColor = selectedColor || COLOR.white;
    if (selectedGender === 'female') {
      // Kvinnlig figur: rita en lätt utsvängd form som en klänning
      ctx.beginPath();
      ctx.moveTo(x + w * 0.25, y + 20);
      ctx.lineTo(x + w * 0.75, y + 20);
      ctx.lineTo(x + w * 0.9,  y + h - 4);
      ctx.lineTo(x + w * 0.1,  y + h - 4);
      ctx.closePath();
      ctx.fillStyle = bodyColor;
      ctx.fill();
    } else {
      // Manlig figur: rektangulär kropp med rundade hörn
      roundedRect(x + 10, y + 20, w - 20, h - 24, 6, bodyColor, true);
    }
    // Huvud: cirkel högst upp (vita för neutral hudton)
    ctx.beginPath();
    ctx.arc(x + w/2, y + 12, 10, 0, Math.PI * 2);
    ctx.fillStyle = COLOR.white;
    ctx.fill();
    // Hår/hatt: mörk båge över huvudet för att tydliggöra domaren
    ctx.beginPath();
    ctx.arc(x + w/2, y + 11, 10, Math.PI * 0.1, Math.PI * 0.9);
    ctx.strokeStyle = COLOR.bg;
    ctx.lineWidth = 4;
    ctx.stroke();
    // Tillbehör: gavel eller lagtema
    if (selectedAccessory === 'gavel') {
      // Domarklubba: handtag och huvud (ritas i vitt för att synas)
      ctx.fillStyle = COLOR.white;
      // handtag
      ctx.fillRect(x + w - 18, y + 26, 5, 22);
      // huvud på klubban
      ctx.fillRect(x + w - 25, y + 46, 16, 6);
    } else if (selectedAccessory === 'law') {
      // Lagtema: rita en liten lagbok med paragraf-tecken i handen
      // Bok
      const bx = x + w - 22;
      const by = y + 36;
      const bw = 14;
      const bh = 18;
      // bokkropp
      roundedRect(bx, by, bw, bh, 3, COLOR.blue, true);
      // §-symbolens bågar
      ctx.strokeStyle = COLOR.white;
      ctx.lineWidth = 1.2;
      // övre cirkel
      ctx.beginPath();
      ctx.arc(bx + bw/2, by + 5, 3, 0, Math.PI * 2);
      ctx.stroke();
      // nedre cirkel
      ctx.beginPath();
      ctx.arc(bx + bw/2, by + 11, 3, 0, Math.PI * 2);
      ctx.stroke();
      // vertikal linje mellan cirklarna
      ctx.beginPath();
      ctx.moveTo(bx + bw/2, by + 2);
      ctx.lineTo(bx + bw/2, by + 16);
      ctx.stroke();
    }
  }

  function drawBlue(x,y,type){
    // kontur för läsbarhet
    ctx.lineWidth = 2;
    ctx.strokeStyle = COLOR.white;
    ctx.fillStyle = COLOR.blue;
    if (type==="law"){
      // bok
      roundedRect(x-10,y-12,20,24,4,COLOR.blue,true); ctx.stroke();
      ctx.fillStyle = COLOR.white;
      ctx.fillRect(x-3,y-6,6,2); // “titelstreck”
    } else {
      // paragraf “§” enkel symbol
      ctx.beginPath();
      ctx.arc(x, y-4, 6, 0, Math.PI*2);
      ctx.moveTo(x, y-4); ctx.arc(x, y+6, 6, 0, Math.PI*2);
      ctx.strokeStyle = COLOR.white; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, y-10); ctx.lineTo(x, y+12);
      ctx.strokeStyle = COLOR.blue; ctx.lineWidth = 3; ctx.stroke();
      ctx.lineWidth = 2;
    }
  }

  function drawHaz(x,y,type){
    // gradient mellan haz1/haz2
    const g = ctx.createLinearGradient(x-10,y-10,x+10,y+10);
    g.addColorStop(0, COLOR.haz1); g.addColorStop(1, COLOR.haz2);
    ctx.fillStyle = g; ctx.strokeStyle = COLOR.white; ctx.lineWidth = 1.5;
    if (type==="fire"){
      ctx.beginPath();
      ctx.moveTo(x, y-12); ctx.bezierCurveTo(x+10,y-4, x+10,y+10, x,y+12);
      ctx.bezierCurveTo(x-10,y+10, x-10,y-4, x,y-12);
      ctx.fill(); ctx.stroke();
    } else if (type==="bolt"){
      ctx.beginPath();
      ctx.moveTo(x-6, y-12); ctx.lineTo(x+4, y-2); ctx.lineTo(x-2, y-2);
      ctx.lineTo(x+6, y+12); ctx.lineTo(x-4, y+2); ctx.lineTo(x+2, y+2);
      ctx.closePath(); ctx.fill(); ctx.stroke();
    } else { // rock
      roundedRect(x-12,y-10,24,20,4,g,true); ctx.stroke();
    }
  }

  // Rita sprickor för sköra plattformar. Ju lägre hitsLeft desto större sprickor.
  function drawCracks(x, y, w, h, hitsLeft){
    // hitsLeft = 3: små sprickor, 2: medel, 1: stora
    ctx.save();
    ctx.strokeStyle = COLOR.haz2;
    ctx.lineWidth = 1.5;
    if (hitsLeft <= 3){
      // diagonal spricka från vänster upp till höger ner
      ctx.beginPath();
      ctx.moveTo(x + w*0.2, y + 1);
      ctx.lineTo(x + w*0.8, y + h - 1);
      ctx.stroke();
    }
    if (hitsLeft <= 2){
      // motsatt diagonal
      ctx.beginPath();
      ctx.moveTo(x + w*0.8, y + 1);
      ctx.lineTo(x + w*0.2, y + h - 1);
      ctx.stroke();
    }
    if (hitsLeft <= 1){
      // vertikal spricka
      ctx.beginPath();
      ctx.moveTo(x + w/2, y);
      ctx.lineTo(x + w/2, y + h);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Rita slut-overlay med kupongkod. Visas när gameOver är sant.
  function drawEndOverlay(){
    // Bakgrund
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,W,H);
    ctx.textAlign = "center";
    // Huvudrubrik: vinst eller förlust
    ctx.fillStyle = COLOR.white;
    ctx.font = "700 26px system-ui, sans-serif";
    if (currentAmount >= SCORE_CAP) {
      ctx.fillText("GRATTIS! Du vann 500 kr", W/2, H/2 - 60);
    } else {
      ctx.fillText("Spelet över", W/2, H/2 - 60);
      ctx.font = "16px system-ui, sans-serif";
      ctx.fillText(`Du nådde ${score} kr`, W/2, H/2 - 30);
    }
    // Generera kupong om inte redan genererad
    if (!couponCode) {
      const res = generateCoupon(currentAmount);
      couponCode = res.code;
      couponExpiry = res.expiry;
    }
    // Visa kod i monospace blått
    ctx.font = "bold 20px Courier New, monospace";
    ctx.fillStyle = COLOR.blue;
    ctx.fillText(couponCode, W/2, H/2 + 10);
    // Visa giltighetsdatum och instruktioner
    ctx.fillStyle = COLOR.white;
    ctx.font = "14px system-ui, sans-serif";
    const expiryStr = couponExpiry.toLocaleDateString('sv-SE');
    ctx.fillText(`Giltig t.o.m. ${expiryStr}`, W/2, H/2 + 34);
    ctx.fillText("Presentera koden för avdrag", W/2, H/2 + 54);
    ctx.fillText("Ladda om sidan för att spela igen.", W/2, H/2 + 74);
    ctx.textAlign = "start";
  }

  // ======= Hjälp-funktioner =======
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function randRange(a,b){ return a + Math.random()*(b-a); }
  function rectHit(x1,y1,w1,h1,x2,y2,w2,h2){
    return x1 < x2+w2 && x1+w1 > x2 && y1 < y2+h2 && y1+h1 > y2;
  }
  function rectHitObj(a,b){ return rectHit(a.x,a.y,a.w,a.h,b.x,b.y,b.w,b.h); }
  function shrinkRect(r,f){ const dw=r.w*(1-f), dh=r.h*(1-f); return {x:r.x+dw/2, y:r.y+dh/2, w:r.w-dw, h:r.h-dh}; }

  function minHazSeparationOK(x){
    // Minsta separation mellan samtidiga faror: 10 % skärmbredd
    const minDx = W*0.10;
    for (const h of hazDrops){
      if (Math.abs(h.x - x) < minDx) return false;
    }
    return true;
  }

  function pickHazardType(){
    const s = score;
    const r = Math.random();
    // 0–100: fire standard; ≥100: bolt inträde; ≥300: rock inträde
    if (s<100) return "fire";
    if (s<300){
      return (r<0.10) ? "bolt" : "fire";
    } else {
      if (r<0.10) return "bolt";
      if (r<0.30) return "rock";
      return "fire";
    }
  }

  function pickXAvoidCone(minX, maxX, tries=8){
    for (let i=0;i<tries;i++){
      const x = randRange(18, W-18);
      if (x < minX || x > maxX) return x;
    }
    return null;
  }
  function pickBlueX(minX, maxX){
    // 60% enkla (mitt), 30% medel, 10% risk (nära faror)
    const r = Math.random();
    let x = W*0.5 + randRange(-W*0.2, W*0.2);
    if (r<0.3) x = W*0.5 + randRange(-W*0.35, W*0.35);
    if (r<0.1) x = (Math.random()<0.5? W*0.12 : W*0.88) + randRange(-12,12);
    // undvik cone
    if (x > minX && x < maxX) x = (x < W*0.5? minX-12 : maxX+12);
    return clamp(x, 14, W-14);
  }

  function extendShield(baseSec){
    if (player.hasShield){
      player.shieldTime = Math.min(8.0, player.shieldTime + baseSec*0.8);
    } else {
      player.hasShield = true;
      player.shieldTime = Math.min(8.0, baseSec);
    }
  }

  // Generera en unik kupongkod baserad på datum, tid och belopp
  // Generera en unik kupongkod baserad på datum, tid och belopp
  function generateCoupon(amount){
    const now = new Date();
    // Datum i format YYYYMMDD
    const dateStr = now.toISOString().slice(0,10).replace(/-/g, "");
    // Tid som HHMM
    const timeStr = String(now.getHours()).padStart(2,'0') + String(now.getMinutes()).padStart(2,'0');
    // Kombinera datum och tid och konvertera till bas36 för maskering
    const combined = String(parseInt(dateStr + timeStr, 10));
    const encoded = BigInt(combined).toString(36).toUpperCase();
    // Beloppet i bas36, paddat till minst två tecken
    const amt = Math.max(0, Math.round(amount || 0));
    const amountEncoded = amt.toString(36).toUpperCase().padStart(2, '0');
    // Prefix för Jurigo
    const code = 'JG' + encoded + amountEncoded;
    // Giltighet: 30 dagar
    const expiry = new Date(now.getTime() + 30*24*60*60*1000);
    return {code, expiry};
  }

})();
</script>
</body>
</html>