<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <title>JURIGO JUMP</title>
  <style>
    /* Basic resets and layout */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
      background-color: #223A6B; /* djup blå bakgrund */
      color: #FFFFFF;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin-top: 20px;
      margin-bottom: 10px;
      font-size: 24px;
      color: #D8CAB8; /* beige rubrik */
    }
    #gameCanvas {
      width: 360px;
      height: 600px;
      border: 2px solid #D8CAB8;
      border-radius: 8px;
      background-color: #223A6B;
    }
    #ui {
      margin-top: 12px;
      text-align: center;
    }
    button {
      background-color: #D8CAB8;
      color: #223A6B;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      margin: 6px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      opacity: 0.9;
    }
    #scoreDisplay, #discountDisplay, #codeDisplay {
      margin: 6px 0;
    }

    /* Kontroller för mobilt spelande */
    #controls {
      margin-top: 12px;
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    #controls button {
      width: 60px;
      height: 60px;
      background-color: #D8CAB8;
      border: none;
      border-radius: 8px;
      color: #223A6B;
      font-size: 32px;
      line-height: 60px;
      text-align: center;
      cursor: pointer;
      user-select: none;
    }
    #controls button:active {
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h1>JURIGO JUMP</h1>
  <canvas id="gameCanvas" width="360" height="600"></canvas>
  <div id="ui"></div>
  <!-- Kontroller för mobila enheter: vänster och höger pilar -->
  <div id="controls">
    <button id="leftBtn">◄</button>
    <button id="rightBtn">►</button>
  </div>

  <script>
    /*
     * Jurigo Jump – ett enkelt skicklighetsspel inspirerat av Doodle Jump.
     * Spelaren styr ett "dokument" som hoppar uppåt mellan plattformar. 
     * Poängen ökar ju högre man kommer. Vid spelavslut genereras en rabattkod
     * baserad på poängen, upp till 500 kr. 
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Konstanter för färgpalett
    const COLOR_BG = '#223A6B';
    const COLOR_PLATFORM = '#D8CAB8';
    const COLOR_PLAYER = '#D8CAB8';
    const COLOR_ACCENT = '#FFFFFF';

    // Spelvariabler
    // Basbredd för plattformar. Själva plattformarna får individuella bredder (plat.w)
    const basePlatformWidth = 60;
    const platformHeight = 12;
    const numPlatforms = 8;
    let platforms = [];
    let player;
    let cameraY;
    let score;
    let gameOver;
    let keys = { left: false, right: false };

    // Tillägg för avancerat spel: sannolikheter och bonusar
    // Sannolikhet att en plattform är en fälla (dödsfälla). Ökar med svårighetsgrad men är alltid låg.
    const BASE_HAZARD_PROB = 0.05;
    // Sannolikhet att en plattform är skör (går sönder efter några hopp). Ökar med svårighetsgrad.
    const BASE_FRAGILE_PROB = 0.3;
    // Sannolikhet att en plattform får ett samlarobjekt (lagbok, våg eller klubba).
    const BASE_ITEM_PROB = 0.2;
    // Poängbonus för att plocka ett samlarobjekt
    const ITEM_SCORE_BONUS = 500;
    // Objekt som kan samlas
    const ITEMS = ['lawbook', 'scales', 'gavel'];

    // Initialisering av spelet
    function init() {
      platforms = [];
      // Startar kameran vid 0 – desto högre den flyttas upp, desto högre poäng
      cameraY = 0;
      score = 0;
      gameOver = false;

      // Skapa plattformar med slumpade x-positioner men jämn y-fördelning
      // Den nedersta plattformen placeras direkt under spelaren för att underlätta starten.
      // Beräkna avstånd mellan plattformar under init. Vi lägger till en extra division för att lämna utrymme under den nedersta plattformen.
      const spacing = canvas.height / (numPlatforms + 1);
      // Skapa spelarens startposition innan vi bestämmer plattformen under den. Spelaren placeras strax ovanför den nedersta plattformen.
      player = {
        x: canvas.width / 2 - 20,
        width: 40,
        height: 60,
        // Lägg spelaren två plattformshöjder ovanför nedersta plattformen minus lite marginal
        y: canvas.height - spacing - 60 - 10,
        vy: 0,
      };
      for (let i = 0; i < numPlatforms; i++) {
        // Fördela plattformar jämnt i vertikalled. Nedersta plattformen (i=0) hamnar vid canvas.height - spacing
        const y = canvas.height - (i + 1) * spacing;
        const w = basePlatformWidth;
        let x;
        // Den nedersta plattformen placeras centrerat under spelaren
        if (i === 0) {
          x = player.x + player.width / 2 - w / 2;
        } else {
          x = Math.random() * (canvas.width - w);
        }
        // Alla startplattformar är stabila och utan objekt
        platforms.push({ x, y, w, type: 'stable', hitsLeft: Infinity, broken: false, item: null });
      }

      // Rensa UI
      document.getElementById('ui').innerHTML = '';
    }

    // Inputhantering
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') keys.left = true;
      if (e.key === 'ArrowRight') keys.right = true;
      // Starta om spelet när man trycker på mellanslag efter game over
      if (gameOver && e.key === ' ') {
        init();
      }
    });
    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') keys.left = false;
      if (e.key === 'ArrowRight') keys.right = false;
    });

    // Pekknappar för mobilt spelande – håll ned för kontinuerlig rörelse
    // Vi hämtar referenser till knapparna
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    // Funktioner för att sätta tangentstatus
    function setLeftDown() { keys.left = true; }
    function setLeftUp() { keys.left = false; }
    function setRightDown() { keys.right = true; }
    function setRightUp() { keys.right = false; }
    if (leftBtn && rightBtn) {
      // Mus-event för desktop
      leftBtn.addEventListener('mousedown', (e) => { e.preventDefault(); setLeftDown(); });
      leftBtn.addEventListener('mouseup', (e) => { e.preventDefault(); setLeftUp(); });
      leftBtn.addEventListener('mouseleave', (e) => { e.preventDefault(); setLeftUp(); });
      rightBtn.addEventListener('mousedown', (e) => { e.preventDefault(); setRightDown(); });
      rightBtn.addEventListener('mouseup', (e) => { e.preventDefault(); setRightUp(); });
      rightBtn.addEventListener('mouseleave', (e) => { e.preventDefault(); setRightUp(); });
      // Touch-event för mobila enheter
      leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); setLeftDown(); });
      leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); setLeftUp(); });
      rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); setRightDown(); });
      rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); setRightUp(); });
    }

    function update() {
      if (gameOver) return;
      // Tillämpa gravitation
      player.vy += 0.5;
      player.y += player.vy;

      // Flytta spelaren i sidled
      // Öka rörelsehastigheten något för snabbare spelkänsla
      const moveSpeed = 3.5;
      if (keys.left) player.x -= moveSpeed;
      if (keys.right) player.x += moveSpeed;
      // Wrap around för horisontell rörelse
      if (player.x < -player.width) player.x = canvas.width;
      if (player.x > canvas.width) player.x = -player.width;

      // Plattformskollisioner – bara när spelaren är på väg nedåt
      if (player.vy > 0) {
        for (const plat of platforms) {
          // Hoppa över trasiga plattformar – de går inte att landa på längre
          if (plat.broken) continue;
          if (
            player.x + player.width > plat.x &&
            player.x < plat.x + plat.w &&
            player.y + player.height > plat.y &&
            player.y + player.height < plat.y + platformHeight + player.vy
          ) {
            // Om plattformen är en fälla avslutas spelet direkt
            if (plat.type === 'hazard') {
              endGame();
              return;
            }
            // Studsa spelaren uppåt
            player.vy = -12;
            // Plocka eventuellt samlarobjekt
            if (plat.item) {
              score += ITEM_SCORE_BONUS;
              plat.item = null;
            }
            // Hantera sköra plattformar: minska antal hopp kvar och markera som trasig om de tar slut
            if (plat.type === 'fragile') {
              plat.hitsLeft--;
              if (plat.hitsLeft <= 0) {
                plat.broken = true;
              }
            }
            break;
          }
        }
      }

      // Kamera – om spelaren når en höjd (y) som är högre än hälften av canvashöjden
      const threshold = canvas.height * 0.4;
      if (player.y < threshold) {
        const diff = threshold - player.y;
        player.y = threshold;
        cameraY += diff;
        // Flytta plattformar nedåt relativt kamerans rörelse
        for (const plat of platforms) {
          plat.y += diff;
          // När en plattform försvinner från botten, placera den längst upp med ny x-position och justera bredd/avstånd efter svårighet
          if (plat.y > canvas.height) {
            // När en plattform försvinner från nederkanten placerar vi den ovanför den högsta plattformen.
            // Beräkna svårighetsgrad baserat på poäng: ökar gradvis upp till faktor 3
            const difficulty = 1 + Math.min(score / 2000, 2);
            const baseSpacing = canvas.height / numPlatforms;
            // Mellanrummet ökar med svårigheten men begränsas så att spelaren alltid kan nå nästa plattform
            let spacing = baseSpacing * difficulty;
            const maxGap = 150;
            if (spacing > maxGap) spacing = maxGap;
            // Breddfaktor: slumpa mellan ett minimum (som minskar med svårighet) och 1 för variation
            const minWidthFactor = Math.max(0.4, 1 - 0.2 * difficulty);
            const widthFactor = minWidthFactor + Math.random() * (1 - minWidthFactor);
            plat.w = basePlatformWidth * widthFactor;
            // Bestäm den nya y-positionen ovanför den nuvarande högsta plattformen
            const minY = Math.min(...platforms.map(p => p.y));
            plat.y = minY - spacing;
            // Slumpa en ny x-position inom canvasens bredd
            plat.x = Math.random() * (canvas.width - plat.w);
            // Återställ status: plattform är inte trasig
            plat.broken = false;
            // Bestäm plattformstyp och samlarobjekt beroende på svårighetsgrad
            // Justera sannolikheter baserat på svårighet
            let hazardProb = BASE_HAZARD_PROB + 0.03 * (difficulty - 1);
            let fragileProb = BASE_FRAGILE_PROB + 0.1 * (difficulty - 1);
            let itemProb = BASE_ITEM_PROB;
            // Begränsa sannolikheterna mellan 0 och 0.9 så att vi alltid har ett rimligt antal säkra plattformar
            hazardProb = Math.min(Math.max(hazardProb, 0), 0.2);
            fragileProb = Math.min(Math.max(fragileProb, 0), 0.7);
            // Undvik fällor i början av spelet (låga poäng) genom att sätta hazardProb till 0 om poängen är låg
            if (score < 1000) hazardProb = 0;
            // Slumpa typ baserat på fördelningen
            const r = Math.random();
            if (r < hazardProb) {
              // Fälla: om spelaren landar på den tar spelet slut
              plat.type = 'hazard';
              plat.hitsLeft = 1;
              plat.item = null;
            } else if (r < hazardProb + fragileProb) {
              // Skör plattform: klarar bara ett begränsat antal hopp
              plat.type = 'fragile';
              plat.hitsLeft = 3;
              plat.item = null;
            } else {
              // Stabil plattform
              plat.type = 'stable';
              plat.hitsLeft = Infinity;
              plat.item = null;
            }
            // Tilldela eventuellt samlarobjekt om plattformen inte är en fälla
            if (plat.type !== 'hazard' && Math.random() < itemProb) {
              // Välj ett slumpmässigt objekt
              const idx = Math.floor(Math.random() * ITEMS.length);
              plat.item = ITEMS[idx];
            }
          }
        }
        score = Math.max(score, Math.floor(cameraY));
      }

      // Game over – spelaren faller under nederkanten av canvas
      if (player.y > canvas.height) {
          endGame();
      }
    }

    function draw() {
      // Bakgrund
      ctx.fillStyle = COLOR_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Plattformar med runda hörn
      for (const plat of platforms) {
        // Rita inte trasiga plattformar
        if (plat.broken) continue;
        // Välj basfärg beroende på plattformstyp
        let baseColor;
        if (plat.type === 'hazard') {
          // Fällor är mörka för att ge en tydlig varning
          baseColor = COLOR_BG;
        } else if (plat.type === 'fragile') {
          // Sköra plattformar är vita så de skiljer sig tydligt från de stabila
          baseColor = COLOR_ACCENT;
        } else {
          // Stabil plattform
          baseColor = COLOR_PLATFORM;
        }
        ctx.fillStyle = baseColor;
        drawRoundedRect(ctx, plat.x, plat.y, plat.w, platformHeight, 6);
        // Överlagring baserat på typ
        if (plat.type === 'fragile') {
          // Sköra plattformar får tydliga sprickor och tjockare linjer
          drawCracks(ctx, plat.x, plat.y, plat.w, platformHeight);
        } else if (plat.type === 'hazard') {
          // Fällor markeras med ett kors i beige färg för att synas mot den mörka bakgrunden
          ctx.strokeStyle = COLOR_PLATFORM;
          drawHazardIcon(ctx, plat.x + plat.w / 2, plat.y + platformHeight / 2, plat.w, platformHeight);
        }
        // Rita samlarobjekt om det finns
        if (plat.item) {
          drawItemIcon(ctx, plat.x + plat.w / 2, plat.y + platformHeight / 2, plat.item);
        }
        // Inga övriga ikoner – vi tar bort mönstret för att ge ett renare och mer juridiskt tema
      }

      // Spelare som juristdomare med domarklubba
      drawJudge(ctx, player.x, player.y, player.width, player.height);

      // Poängvisning i övre vänstra hörnet
      ctx.fillStyle = COLOR_ACCENT;
      ctx.font = '16px sans-serif';
      ctx.fillText('Poäng: ' + score, 8, 20);
    }

    function drawRoundedRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      ctx.fill();
    }

    // Ritfunktion för subtile ikoner på plattformar
    function drawPlatformIcon(ctx, cx, cy) {
      // slumpa mellan några olika ikoner: pass, kontrakt, box, hus
      const rand = Math.floor((cx + cy) % 4);
      ctx.strokeStyle = COLOR_BG;
      ctx.lineWidth = 2;
      ctx.beginPath();
      switch (rand) {
        case 0: // hus
          ctx.moveTo(cx - 6, cy + 4);
          ctx.lineTo(cx - 6, cy);
          ctx.lineTo(cx, cy - 6);
          ctx.lineTo(cx + 6, cy);
          ctx.lineTo(cx + 6, cy + 4);
          break;
        case 1: // kontrakt (papper)
          ctx.rect(cx - 5, cy - 5, 10, 10);
          break;
        case 2: // pass/bok
          ctx.rect(cx - 5, cy - 4, 10, 8);
          ctx.moveTo(cx - 3, cy - 4);
          ctx.lineTo(cx - 3, cy + 4);
          break;
        case 3: // box
          ctx.rect(cx - 4, cy - 4, 8, 8);
          ctx.moveTo(cx - 4, cy);
          ctx.lineTo(cx + 4, cy);
          ctx.moveTo(cx, cy - 4);
          ctx.lineTo(cx, cy + 4);
          break;
      }
      ctx.stroke();
    }

    // Ritfunktion för att rita sprickor på sköra plattformar
    function drawCracks(ctx, x, y, w, h) {
      ctx.strokeStyle = COLOR_BG;
      // Använd en något tjockare linje för att göra sprickorna tydliga
      ctx.lineWidth = 3;
      // Rita två diagonala sprickor som bildar ett tydligt "X"
      ctx.beginPath();
      ctx.moveTo(x + w * 0.1, y + h * 0.2);
      ctx.lineTo(x + w * 0.9, y + h * 0.8);
      ctx.moveTo(x + w * 0.9, y + h * 0.2);
      ctx.lineTo(x + w * 0.1, y + h * 0.8);
      ctx.stroke();
    }

    // Ritfunktion för fällor: ritar ett X över plattformen
    function drawHazardIcon(ctx, cx, cy, w, h) {
      // Använd den aktuella strokeStyle som sätts av den anropande koden för att rita korset
      // Gör korset tydligare genom att använda en något tjockare linje
      ctx.lineWidth = 3;
      const halfW = w * 0.4;
      const halfH = h * 0.4;
      ctx.beginPath();
      ctx.moveTo(cx - halfW, cy - halfH);
      ctx.lineTo(cx + halfW, cy + halfH);
      ctx.moveTo(cx + halfW, cy - halfH);
      ctx.lineTo(cx - halfW, cy + halfH);
      ctx.stroke();
    }

    // Ritfunktion för samlarobjekt (lagbok, våg, domarklubba)
    function drawItemIcon(ctx, cx, cy, item) {
      ctx.strokeStyle = COLOR_BG;
      ctx.lineWidth = 2;
      ctx.beginPath();
      switch (item) {
        case 'lawbook':
          // Ett enkelt bok/pärm-symbol
          ctx.rect(cx - 5, cy - 4, 10, 8);
          ctx.moveTo(cx - 3, cy - 4);
          ctx.lineTo(cx - 3, cy + 4);
          break;
        case 'scales':
          // Våg-symbol: central pelare och två fat
          // pelare
          ctx.moveTo(cx, cy - 5);
          ctx.lineTo(cx, cy + 5);
          // översta tvärbalk
          ctx.moveTo(cx - 6, cy - 1);
          ctx.lineTo(cx + 6, cy - 1);
          // vänster fat
          ctx.moveTo(cx - 5, cy + 2);
          ctx.lineTo(cx - 7, cy + 4);
          ctx.lineTo(cx - 3, cy + 4);
          ctx.closePath();
          ctx.moveTo(cx + 5, cy + 2);
          ctx.lineTo(cx + 7, cy + 4);
          ctx.lineTo(cx + 3, cy + 4);
          ctx.closePath();
          break;
        case 'gavel':
          // En liten klubba: skaft och huvud
          ctx.moveTo(cx - 5, cy);
          ctx.lineTo(cx + 5, cy);
          ctx.moveTo(cx + 3, cy - 3);
          ctx.lineTo(cx + 3, cy + 3);
          break;
      }
      ctx.stroke();
    }

    // Ritfunktion för spelaren: en juristdomare med domarklubba
    function drawJudge(ctx, x, y, w, h) {
      /*
       * Figuren består av en enkel kropp (klädnad), ett huvud och en klubba.
       * Vi använder endast de färger som definierats i paletten.
       */
      // Kropp/rock
      const bodyWidth = w * 0.6;
      const bodyHeight = h * 0.5;
      const bodyX = x + (w - bodyWidth) / 2;
      const bodyY = y + h - bodyHeight;
      ctx.fillStyle = COLOR_PLAYER;
      drawRoundedRect(ctx, bodyX, bodyY, bodyWidth, bodyHeight, 4);

      // Huvud som en cirkel
      const headRadius = w * 0.18;
      const headX = x + w / 2;
      const headY = bodyY - headRadius;
      ctx.beginPath();
      ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
      ctx.fill();

      // Domarklubba: ett handtag och en klubbskaft
      const handleLength = w * 0.5;
      const handleThickness = w * 0.05;
      const handleX = x + w;
      const handleY = bodyY + bodyHeight * 0.3;
      ctx.fillRect(handleX, handleY, handleLength, handleThickness);
      // Klubban (hammarens huvud)
      const hammerWidth = w * 0.12;
      const hammerHeight = w * 0.08;
      const hammerX = handleX + handleLength - hammerWidth * 0.5;
      const hammerY = handleY - hammerHeight * 0.5;
      ctx.fillRect(hammerX, hammerY, hammerWidth, hammerHeight);
    }

    function endGame() {
      gameOver = true;
      // Räkna ut rabatt baserat på poäng (100 kr per 1000 poäng, max 500 kr)
      const discount = Math.min(Math.floor(score / 1000) * 100, 500);
      // Generera en simpel kod med slumpmässiga tecken
      const randStr = Math.random().toString(36).substr(2, 6).toUpperCase();
      const code = `JURI-${discount}-${randStr}`;
      // Visa UI med resultat
      const ui = document.getElementById('ui');
      ui.innerHTML = '';
      const scoreEl = document.createElement('div');
      scoreEl.id = 'scoreDisplay';
      scoreEl.textContent = `Din poäng: ${score}`;
      ui.appendChild(scoreEl);
      const discountEl = document.createElement('div');
      discountEl.id = 'discountDisplay';
      discountEl.textContent = `Rabatt: ${discount} kr`;
      ui.appendChild(discountEl);
      const codeEl = document.createElement('div');
      codeEl.id = 'codeDisplay';
      codeEl.textContent = `Kod: ${code}`;
      ui.appendChild(codeEl);
      // Kopieringsknapp
      const copyBtn = document.createElement('button');
      copyBtn.textContent = 'Kopiera kod';
      copyBtn.onclick = () => {
        navigator.clipboard.writeText(code);
        copyBtn.textContent = 'Kopierad!';
        setTimeout(() => copyBtn.textContent = 'Kopiera kod', 1500);
      };
      ui.appendChild(copyBtn);
      // Spela igen-knapp
      const replayBtn = document.createElement('button');
      replayBtn.textContent = 'Spela igen';
      replayBtn.onclick = init;
      ui.appendChild(replayBtn);
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    init();
    loop();
  </script>
</body>
</html>